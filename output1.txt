Attempting to connect to database
awaiting server
configuring app
setting up apis
setting up users
setting up matches
setting up location
setting up subjects
setting up tokens
setting up notifications
setting up match notifications
setting up statuses
Configuring static paths
Syncing models
Executing (default): CREATE TABLE IF NOT EXISTS `DeliveryCategories` (`category` VARCHAR(255) NOT NULL PRIMARY KEY);
Executing (default): PRAGMA INDEX_LIST(`DeliveryCategories`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_DeliveryCategories_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `FirebaseTokens` (`id` VARCHAR(255) NOT NULL PRIMARY KEY, `token` VARCHAR(255));
Executing (default): PRAGMA INDEX_LIST(`FirebaseTokens`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_FirebaseTokens_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `Users` (`id` VARCHAR(255) PRIMARY KEY, `pwHash` CHAR(60) NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Users`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_Users_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `Geolocations` (`id` INTEGER PRIMARY KEY AUTOINCREMENT REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `latitude` VARCHAR(255), `longitude` VARCHAR(255), `userID` VARCHAR(255) REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `createdAt` DATETIME NOT NULL, `updatedAt` DATETIME NOT NULL);
Executing (default): PRAGMA INDEX_LIST(`Geolocations`)
Executing (default): CREATE TABLE IF NOT EXISTS `Matches` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `requester_id` VARCHAR(255), `provider_id` VARCHAR(255), `service_type` VARCHAR(255) NOT NULL, `subject_1` VARCHAR(255), `subject_2` VARCHAR(255), `subject_3` VARCHAR(255), `details` VARCHAR(255), `time` FLOAT, `location` JSON, `timetodeliver` FLOAT, `provider_score` FLOAT, `requester_score` FLOAT, `dropOffLocation` JSON);
Executing (default): PRAGMA INDEX_LIST(`Matches`)
Executing (default): CREATE TABLE IF NOT EXISTS `MatchNotifications` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `matches` VARCHAR(255), `message` VARCHAR(255), `statuses` VARCHAR(255), `matchID` INTEGER, `maxAttempt` INTEGER);
Executing (default): PRAGMA INDEX_LIST(`MatchNotifications`)
Executing (default): CREATE TABLE IF NOT EXISTS `Notifications` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `to` VARCHAR(255) NOT NULL, `from` VARCHAR(255), `message` VARCHAR(255), `title` VARCHAR(255), `status` VARCHAR(255), `prev` INTEGER, `next` INTEGER, `attempts` INTEGER, `matchID` INTEGER, `listID` INTEGER);
Executing (default): PRAGMA INDEX_LIST(`Notifications`)
Executing (default): CREATE TABLE IF NOT EXISTS `NotificationLists` (`id` INTEGER PRIMARY KEY AUTOINCREMENT, `first` INTEGER NOT NULL, `last` INTEGER, `attempts` INTEGER);
Executing (default): PRAGMA INDEX_LIST(`NotificationLists`)
Executing (default): CREATE TABLE IF NOT EXISTS `Profiles` (`id` VARCHAR(255) PRIMARY KEY REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `nameFirst` VARCHAR(255) NOT NULL, `nameLast` VARCHAR(255) NOT NULL, `phone` VARCHAR(255), `bio` VARCHAR(2047), `tutoring` JSON, `delivery` JSON, `tutoringNeeds` JSON, `deliveryNeeds` JSON);
Executing (default): PRAGMA INDEX_LIST(`Profiles`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_Profiles_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `Statuses` (`id` VARCHAR(255) NOT NULL PRIMARY KEY, `status` VARCHAR(255));
Executing (default): PRAGMA INDEX_LIST(`Statuses`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_Statuses_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `TutoringSubjects` (`subject` VARCHAR(255) NOT NULL PRIMARY KEY);
Executing (default): PRAGMA INDEX_LIST(`TutoringSubjects`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_TutoringSubjects_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `MatchHistory` (`provider_id` VARCHAR(255) NOT NULL REFERENCES `Users` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, `userId` INTEGER NOT NULL REFERENCES `Matches` (`id`) ON DELETE CASCADE ON UPDATE CASCADE, PRIMARY KEY (`provider_id`, `userId`));
Executing (default): PRAGMA INDEX_LIST(`MatchHistory`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_MatchHistory_1`)
Executing (default): CREATE TABLE IF NOT EXISTS `Sessions` (`sid` VARCHAR(36) PRIMARY KEY, `expires` DATETIME, `data` TEXT);
Executing (default): PRAGMA INDEX_LIST(`Sessions`)
Executing (default): PRAGMA INDEX_INFO(`sqlite_autoindex_Sessions_1`)
Setting up server
waited for server
Listening at http://:::5000
Executing (default): DELETE FROM `Sessions` WHERE `expires` < '2019-05-13 20:36:33.245 +00:00'
get try
deliveryCategories
Getting all delivery
get try
Getting all tutoring
Executing (8025336c-6aa9-47ec-a716-26ed3a00f224): BEGIN DEFERRED TRANSACTION;
Executing (bdb0ba79-1233-42e7-b7da-64b38f83f646): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (8025336c-6aa9-47ec-a716-26ed3a00f224): COMMIT;
Executing (bdb0ba79-1233-42e7-b7da-64b38f83f646): COMMIT;
Found successfully
Found successfully
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (042759e8-907d-48f5-86fd-bb6fb8d76ca6): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (042759e8-907d-48f5-86fd-bb6fb8d76ca6): COMMIT;
put try
{ latitude: 40.44505672789485,
  longitude: -79.94515353000547,
  userID: 'sarah' }
Attempting to insert
sarah
Attempting insert...
sarah
Executing (57d5cc97-02c4-489d-8a34-8752fd09b729): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Geolocations` (`id`,`latitude`,`longitude`,`userID`,`createdAt`,`updatedAt`) VALUES (NULL,$1,$2,$3,$4,$5);
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (57d5cc97-02c4-489d-8a34-8752fd09b729): COMMIT;
Inserted successfully
put try
{ latitude: 40.44503387700952,
  longitude: -79.94517540877008,
  userID: 'sarah' }
Attempting to insert
sarah
Attempting insert...
sarah
Executing (faea6d17-0efe-4039-b897-b62047e42c9c): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Geolocations` (`id`,`latitude`,`longitude`,`userID`,`createdAt`,`updatedAt`) VALUES (NULL,$1,$2,$3,$4,$5);
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (faea6d17-0efe-4039-b897-b62047e42c9c): COMMIT;
Inserted successfully
put try
Attempting to insert
Attempting insert...
{ requester_id: '',
  provider_id: 'sarah',
  service_type: 'delivery',
  subject: 'Food',
  details: 'Lulu\'s Noodles',
  time: 0,
  location: { lat: 40.4451455, lng: -79.94905179999999 },
  score: 0,
  dropOffLocation: { lat: 40.445056645352835, lng: -79.94671113789082 } }
Executing (885a3e0e-283a-4990-ba04-fab3a9eb996b): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Matches` (`id`,`requester_id`,`provider_id`,`service_type`,`details`,`time`,`location`,`dropOffLocation`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7);
Executing (885a3e0e-283a-4990-ba04-fab3a9eb996b): COMMIT;
Inserted successfully
Getting matches API
IncomingMessage {
  _readableState:
   ReadableState {
     objectMode: false,
     highWaterMark: 16384,
     buffer: BufferList { length: 0 },
     length: 0,
     pipes: null,
     pipesCount: 0,
     flowing: null,
     ended: false,
     endEmitted: false,
     reading: false,
     sync: true,
     needReadable: false,
     emittedReadable: false,
     readableListening: false,
     resumeScheduled: false,
     emitClose: true,
     destroyed: false,
     defaultEncoding: 'utf8',
     awaitDrain: 0,
     readingMore: true,
     decoder: null,
     encoding: null },
  readable: true,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 447,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1329234,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 537,
        [Symbol(triggerId)]: 449 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  connection:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 447,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1329234,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 537,
        [Symbol(triggerId)]: 449 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: false,
  headers:
   { host: '128.2.204.187:5000',
     accept: '*/*',
     'accept-language': 'en-us',
     connection: 'keep-alive',
     'accept-encoding': 'gzip, deflate',
     'user-agent': 'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' },
  rawHeaders:
   [ 'Host',
     '128.2.204.187:5000',
     'Accept',
     '*/*',
     'Accept-Language',
     'en-us',
     'Connection',
     'keep-alive',
     'Accept-Encoding',
     'gzip, deflate',
     'User-Agent',
     'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url:
   '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
  method: 'GET',
  statusCode: null,
  statusMessage: null,
  client:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 447,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1329234,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 537,
        [Symbol(triggerId)]: 449 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  _consuming: false,
  _dumped: false,
  next: [Function: next],
  baseUrl: '/api/match',
  originalUrl:
   '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
  _parsedUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     pathname: '/',
     path:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     href:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     _raw:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah' },
  params: {},
  query:
   { limit: '5',
     offer:
      '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"Lulu\'s Noodles","timetodeliver":3.3053134724939164,"dropofflocation":{"lat":40.445056645352835,"lng":-79.94671113789082},"location":{"lat":40.4451455,"lng":-79.94905179999999}}',
     matchID: '727',
     provider_id: 'sarah' },
  res:
   ServerResponse {
     _events: { finish: [Function: bound resOnFinish] },
     _eventsCount: 1,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: false,
     chunkedEncoding: false,
     shouldKeepAlive: true,
     useChunkedEncodingByDefault: true,
     sendDate: true,
     _removedConnection: false,
     _removedContLen: false,
     _removedTE: false,
     _contentLength: null,
     _hasBody: true,
     _trailer: '',
     finished: false,
     _headerSent: false,
     socket:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 447,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     connection:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 447,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     _header: null,
     _onPendingData: [Function: bound updateOutgoingData],
     _sent100: false,
     _expect_continue: false,
     req: [Circular],
     locals: {},
     writeHead: [Function: writeHead],
     end: [Function: end],
     [Symbol(isCorked)]: false,
     [Symbol(outHeadersKey)]: { 'x-powered-by': [Array] } },
  _parsedOriginalUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     pathname: '/api/match/',
     path:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     href:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah',
     _raw:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Lulu\'s%20Noodles%22,%22timetodeliver%22:3.3053134724939164,%22dropofflocation%22:%7B%22lat%22:40.445056645352835,%22lng%22:-79.94671113789082%7D,%22location%22:%7B%22lat%22:40.4451455,%22lng%22:-79.94905179999999%7D%7D&matchID=727&provider_id=sarah' },
  sessionStore:
   SequelizeStore {
     options:
      { db: [Sequelize],
        checkExpirationInterval: 900000,
        expiration: 86400000,
        disableTouch: false },
     _events:
      { disconnect: [Function: ondisconnect],
        connect: [Function: onconnect] },
     _eventsCount: 2,
     _maxListeners: undefined,
     _expirationInterval:
      Timeout {
        _called: true,
        _idleTimeout: 900000,
        _idlePrev: null,
        _idleNext: null,
        _idleStart: 472,
        _onTimeout: [Function: bound clearExpiredSessions],
        _timerArgs: undefined,
        _repeat: 900000,
        _destroyed: false,
        _handle: [Timer],
        [Symbol(unrefed)]: false,
        [Symbol(asyncId)]: 8,
        [Symbol(triggerId)]: 1 },
     sessionModel: Session,
     generate: [Function] },
  sessionID: 'mrgJqiGbbKz6zFEd7oXVToXIsbPz2rAz',
  session:
   Session {
     cookie:
      { path: '/',
        _expires: null,
        originalMaxAge: null,
        httpOnly: false,
        secure: false } },
  body: {},
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [Array],
        _deserializers: [Array],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer] ],
     methods: { get: true },
     __acl: [Function],
     acl: [Function],
     __bind: [Function],
     bind: [Function],
     __checkout: [Function],
     checkout: [Function],
     __connect: [Function],
     connect: [Function],
     __copy: [Function],
     copy: [Function],
     __delete: [Function],
     delete: [Function],
     __get: [Function],
     get: [Function],
     __head: [Function],
     head: [Function],
     __link: [Function],
     link: [Function],
     __lock: [Function],
     lock: [Function],
     '__m-search': [Function],
     'm-search': [Function],
     __merge: [Function],
     merge: [Function],
     __mkactivity: [Function],
     mkactivity: [Function],
     __mkcalendar: [Function],
     mkcalendar: [Function],
     __mkcol: [Function],
     mkcol: [Function],
     __move: [Function],
     move: [Function],
     __notify: [Function],
     notify: [Function],
     __options: [Function],
     options: [Function],
     __patch: [Function],
     patch: [Function],
     __post: [Function],
     post: [Function],
     __propfind: [Function],
     propfind: [Function],
     __proppatch: [Function],
     proppatch: [Function],
     __purge: [Function],
     purge: [Function],
     __put: [Function],
     put: [Function],
     __rebind: [Function],
     rebind: [Function],
     __report: [Function],
     report: [Function],
     __search: [Function],
     search: [Function],
     __source: [Function],
     source: [Function],
     __subscribe: [Function],
     subscribe: [Function],
     __trace: [Function],
     trace: [Function],
     __unbind: [Function],
     unbind: [Function],
     __unlink: [Function],
     unlink: [Function],
     __unlock: [Function],
     unlock: [Function],
     __unsubscribe: [Function],
     unsubscribe: [Function],
     __all: [Function: all],
     all: [Function] } }
Attempting matching
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Lulu\'s Noodles',
  timetodeliver: 3.3053134724939164,
  dropofflocation: { lat: 40.445056645352835, lng: -79.94671113789082 },
  location: { lat: 40.4451455, lng: -79.94905179999999 } }
727
run
sarah
Executing (default): SELECT `User`.`id`, `Profile`.`id` AS `Profile.id`, `Profile`.`delivery` AS `Profile.delivery` FROM `Users` AS `User` INNER JOIN `Profiles` AS `Profile` ON `User`.`id` = `Profile`.`id` AND json_extract(`Profile`.`deliveryNeeds`, '$.Food') IS NOT NULL;
User {
  dataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'james', delivery: [Object] },
     _previousDataValues: { id: 'james', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'james';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'james';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Lulu\'s Noodles',
  timetodeliver: 3.3053134724939164,
  dropofflocation: { lat: 40.445056645352835, lng: -79.94671113789082 },
  location: { lat: 40.4451455, lng: -79.94905179999999 } }
40.4476788 -79.9514778 40.4451455 -79.94905179999999
{ time: 5.809315227376399 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'james';
getting profile
Profile {
  dataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _previousDataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'james' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
User {
  dataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'alice', delivery: [Object] },
     _previousDataValues: { id: 'alice', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'alice';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'alice';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Lulu\'s Noodles',
  timetodeliver: 3.3053134724939164,
  dropofflocation: { lat: 40.445056645352835, lng: -79.94671113789082 },
  location: { lat: 40.4451455, lng: -79.94905179999999 } }
40.4476602 -79.9514002 40.4451455 -79.94905179999999
{ time: 5.717405760614981 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'alice';
getting profile
Profile {
  dataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _previousDataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'alice' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
[ { id: 'james',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '10',
    time2: 1,
    time_request: 5.809315227376399,
    time2_request: 1 },
  { id: 'alice',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '5',
    time2: 1,
    time_request: 5.717405760614981,
    time2_request: 1 } ]
running python script
delivery
{"0": "james", "1": "alice"}

data
{"0": "james", "1": "alice"}

{ '0': 'james', '1': 'alice' }
[ 'james', 'alice' ]
400 S Craig St, Pittsburgh, PA 15213, USA
400 S Craig St, Pittsburgh, PA 15213, USA
delivery
409 S Neville St, Pittsburgh, PA 15213, USA
409 S Neville St, Pittsburgh, PA 15213, USA
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
208
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
209
Executing (default): INSERT INTO `NotificationLists` (`id`,`first`,`last`,`attempts`) VALUES (NULL,$1,$2,$3);
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 208;
Notification {
  dataValues:
   { id: 208,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 727,
     listID: 97 },
  _previousDataValues:
   { id: 208,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 727,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 208 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting next
208
209
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 208;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
208
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 208;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'james';
Pushing messages
[ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
       next: 209,
       prev: null,
       from: 'sarah',
       to: 'james',
       id: 208,
       time: 0,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 209;
Notification {
  dataValues:
   { id: 209,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 727,
     listID: 97 },
  _previousDataValues:
   { id: 209,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 727,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 209 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
209
208
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 209;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Sending
209
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 209;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'alice';
Pushing messages
[ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:Lulu\'s Noodles\nLocation:400 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:409 S Neville St, Pittsburgh, PA 15213, USA',
       next: null,
       prev: 208,
       from: 'sarah',
       to: 'alice',
       id: 209,
       time: 6000,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
[ { id: 'acc0c6f8-e962-4601-8b1c-f2061a2caa26', status: 'ok' } ]
[ { status: 'ok', id: '36a0d723-b1ae-4aa8-8725-fe0cf9cd1ef0' } ]
get try
Getting all tutoring
Executing (7972481d-7550-477f-978b-00b1770c4e0e): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (7972481d-7550-477f-978b-00b1770c4e0e): COMMIT;
Found successfully
get try
deliveryCategories
Getting all delivery
Executing (38136bde-f738-4131-b07f-22df9d2c2609): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (38136bde-f738-4131-b07f-22df9d2c2609): COMMIT;
Found successfully
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (dd69bd00-7090-4763-b910-b12cb3c05b0e): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (dd69bd00-7090-4763-b910-b12cb3c05b0e): COMMIT;
put try
{ latitude: 40.44496125568043,
  longitude: -79.94524231046229,
  userID: 'sarah' }
Attempting to insert
sarah
Attempting insert...
sarah
Executing (f743aecf-0b19-4aa8-b8d4-469b88e64a7d): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Geolocations` (`id`,`latitude`,`longitude`,`userID`,`createdAt`,`updatedAt`) VALUES (NULL,$1,$2,$3,$4,$5);
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (f743aecf-0b19-4aa8-b8d4-469b88e64a7d): COMMIT;
Inserted successfully
put try
{ latitude: 40.445040501145,
  longitude: -79.94517219872677,
  userID: 'sarah' }
Attempting to insert
sarah
Attempting insert...
sarah
Executing (9d5c6c62-95bb-4d69-ab08-fa1db46bbeaa): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Geolocations` (`id`,`latitude`,`longitude`,`userID`,`createdAt`,`updatedAt`) VALUES (NULL,$1,$2,$3,$4,$5);
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (9d5c6c62-95bb-4d69-ab08-fa1db46bbeaa): COMMIT;
Inserted successfully
put try
Attempting to insert
Attempting insert...
{ requester_id: '',
  provider_id: 'sarah',
  service_type: 'delivery',
  subject: 'Food',
  details: 'Union Grill',
  time: 0,
  location: { lat: 40.444802, lng: -79.94851799999999 },
  score: 0,
  dropOffLocation: { lat: 40.445059413024225, lng: -79.94514826505876 } }
Executing (9a17960b-3553-4c71-9885-6a30834364a9): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Matches` (`id`,`requester_id`,`provider_id`,`service_type`,`details`,`time`,`location`,`dropOffLocation`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7);
Executing (9a17960b-3553-4c71-9885-6a30834364a9): COMMIT;
Inserted successfully
Getting matches API
IncomingMessage {
  _readableState:
   ReadableState {
     objectMode: false,
     highWaterMark: 16384,
     buffer: BufferList { length: 0 },
     length: 0,
     pipes: null,
     pipesCount: 0,
     flowing: null,
     ended: false,
     endEmitted: false,
     reading: false,
     sync: true,
     needReadable: false,
     emittedReadable: false,
     readableListening: false,
     resumeScheduled: false,
     emitClose: true,
     destroyed: false,
     defaultEncoding: 'utf8',
     awaitDrain: 0,
     readingMore: true,
     decoder: null,
     encoding: null },
  readable: true,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1256,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1390663,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1297,
        [Symbol(triggerId)]: 1258 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  connection:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1256,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1390663,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1297,
        [Symbol(triggerId)]: 1258 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: false,
  headers:
   { host: '128.2.204.187:5000',
     accept: '*/*',
     'accept-language': 'en-us',
     connection: 'keep-alive',
     'accept-encoding': 'gzip, deflate',
     'user-agent': 'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' },
  rawHeaders:
   [ 'Host',
     '128.2.204.187:5000',
     'Accept',
     '*/*',
     'Accept-Language',
     'en-us',
     'Connection',
     'keep-alive',
     'Accept-Encoding',
     'gzip, deflate',
     'User-Agent',
     'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url:
   '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
  method: 'GET',
  statusCode: null,
  statusMessage: null,
  client:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1256,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1390663,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1297,
        [Symbol(triggerId)]: 1258 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  _consuming: false,
  _dumped: false,
  next: [Function: next],
  baseUrl: '/api/match',
  originalUrl:
   '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
  _parsedUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     pathname: '/',
     path:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     href:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     _raw:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah' },
  params: {},
  query:
   { limit: '5',
     offer:
      '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"Union Grill","timetodeliver":4.776481030246472,"dropofflocation":{"lat":40.445059413024225,"lng":-79.94514826505876},"location":{"lat":40.444802,"lng":-79.94851799999999}}',
     matchID: '728',
     provider_id: 'sarah' },
  res:
   ServerResponse {
     _events: { finish: [Function: bound resOnFinish] },
     _eventsCount: 1,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: false,
     chunkedEncoding: false,
     shouldKeepAlive: true,
     useChunkedEncodingByDefault: true,
     sendDate: true,
     _removedConnection: false,
     _removedContLen: false,
     _removedTE: false,
     _contentLength: null,
     _hasBody: true,
     _trailer: '',
     finished: false,
     _headerSent: false,
     socket:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 1256,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     connection:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 1256,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     _header: null,
     _onPendingData: [Function: bound updateOutgoingData],
     _sent100: false,
     _expect_continue: false,
     req: [Circular],
     locals: {},
     writeHead: [Function: writeHead],
     end: [Function: end],
     [Symbol(isCorked)]: false,
     [Symbol(outHeadersKey)]: { 'x-powered-by': [Array] } },
  _parsedOriginalUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     pathname: '/api/match/',
     path:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     href:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah',
     _raw:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22Union%20Grill%22,%22timetodeliver%22:4.776481030246472,%22dropofflocation%22:%7B%22lat%22:40.445059413024225,%22lng%22:-79.94514826505876%7D,%22location%22:%7B%22lat%22:40.444802,%22lng%22:-79.94851799999999%7D%7D&matchID=728&provider_id=sarah' },
  sessionStore:
   SequelizeStore {
     options:
      { db: [Sequelize],
        checkExpirationInterval: 900000,
        expiration: 86400000,
        disableTouch: false },
     _events:
      { disconnect: [Function: ondisconnect],
        connect: [Function: onconnect] },
     _eventsCount: 2,
     _maxListeners: undefined,
     _expirationInterval:
      Timeout {
        _called: true,
        _idleTimeout: 900000,
        _idlePrev: null,
        _idleNext: null,
        _idleStart: 472,
        _onTimeout: [Function: bound clearExpiredSessions],
        _timerArgs: undefined,
        _repeat: 900000,
        _destroyed: false,
        _handle: [Timer],
        [Symbol(unrefed)]: false,
        [Symbol(asyncId)]: 8,
        [Symbol(triggerId)]: 1 },
     sessionModel: Session,
     generate: [Function] },
  sessionID: 'hJYxpxwJJ73VC3IMVGgsyMN2566YehUs',
  session:
   Session {
     cookie:
      { path: '/',
        _expires: null,
        originalMaxAge: null,
        httpOnly: false,
        secure: false } },
  body: {},
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [Array],
        _deserializers: [Array],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer] ],
     methods: { get: true },
     __acl: [Function],
     acl: [Function],
     __bind: [Function],
     bind: [Function],
     __checkout: [Function],
     checkout: [Function],
     __connect: [Function],
     connect: [Function],
     __copy: [Function],
     copy: [Function],
     __delete: [Function],
     delete: [Function],
     __get: [Function],
     get: [Function],
     __head: [Function],
     head: [Function],
     __link: [Function],
     link: [Function],
     __lock: [Function],
     lock: [Function],
     '__m-search': [Function],
     'm-search': [Function],
     __merge: [Function],
     merge: [Function],
     __mkactivity: [Function],
     mkactivity: [Function],
     __mkcalendar: [Function],
     mkcalendar: [Function],
     __mkcol: [Function],
     mkcol: [Function],
     __move: [Function],
     move: [Function],
     __notify: [Function],
     notify: [Function],
     __options: [Function],
     options: [Function],
     __patch: [Function],
     patch: [Function],
     __post: [Function],
     post: [Function],
     __propfind: [Function],
     propfind: [Function],
     __proppatch: [Function],
     proppatch: [Function],
     __purge: [Function],
     purge: [Function],
     __put: [Function],
     put: [Function],
     __rebind: [Function],
     rebind: [Function],
     __report: [Function],
     report: [Function],
     __search: [Function],
     search: [Function],
     __source: [Function],
     source: [Function],
     __subscribe: [Function],
     subscribe: [Function],
     __trace: [Function],
     trace: [Function],
     __unbind: [Function],
     unbind: [Function],
     __unlink: [Function],
     unlink: [Function],
     __unlock: [Function],
     unlock: [Function],
     __unsubscribe: [Function],
     unsubscribe: [Function],
     __all: [Function: all],
     all: [Function] } }
Attempting matching
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Union Grill',
  timetodeliver: 4.776481030246472,
  dropofflocation: { lat: 40.445059413024225, lng: -79.94514826505876 },
  location: { lat: 40.444802, lng: -79.94851799999999 } }
728
run
sarah
Executing (default): SELECT `User`.`id`, `Profile`.`id` AS `Profile.id`, `Profile`.`delivery` AS `Profile.delivery` FROM `Users` AS `User` INNER JOIN `Profiles` AS `Profile` ON `User`.`id` = `Profile`.`id` AND json_extract(`Profile`.`deliveryNeeds`, '$.Food') IS NOT NULL;
User {
  dataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'james', delivery: [Object] },
     _previousDataValues: { id: 'james', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'james';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'james';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Union Grill',
  timetodeliver: 4.776481030246472,
  dropofflocation: { lat: 40.445059413024225, lng: -79.94514826505876 },
  location: { lat: 40.444802, lng: -79.94851799999999 } }
40.4476788 -79.9514778 40.444802 -79.94851799999999
{ time: 6.771213890266915 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'james';
getting profile
Profile {
  dataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _previousDataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'james' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
User {
  dataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'alice', delivery: [Object] },
     _previousDataValues: { id: 'alice', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'alice';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'alice';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: 'Union Grill',
  timetodeliver: 4.776481030246472,
  dropofflocation: { lat: 40.445059413024225, lng: -79.94514826505876 },
  location: { lat: 40.444802, lng: -79.94851799999999 } }
40.4476602 -79.9514002 40.444802 -79.94851799999999
{ time: 6.676918896795686 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'alice';
getting profile
Profile {
  dataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _previousDataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'alice' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
[ { id: 'james',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '10',
    time2: 1,
    time_request: 6.771213890266915,
    time2_request: 1 },
  { id: 'alice',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '5',
    time2: 1,
    time_request: 6.676918896795686,
    time2_request: 1 } ]
running python script
delivery
{"0": "alice", "1": "james"}

data
{"0": "alice", "1": "james"}

{ '0': 'alice', '1': 'james' }
[ 'alice', 'james' ]
413 S Craig St, Pittsburgh, PA 15213, USA
413 S Craig St, Pittsburgh, PA 15213, USA
delivery
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
210
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
211
Executing (default): INSERT INTO `NotificationLists` (`id`,`first`,`last`,`attempts`) VALUES (NULL,$1,$2,$3);
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 210;
Notification {
  dataValues:
   { id: 210,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 728,
     listID: 98 },
  _previousDataValues:
   { id: 210,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 728,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 210 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting next
210
211
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 210;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
210
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 210;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'alice';
Pushing messages
[ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 211,
       prev: null,
       from: 'sarah',
       to: 'alice',
       id: 210,
       time: 0,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 211;
Notification {
  dataValues:
   { id: 211,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 728,
     listID: 98 },
  _previousDataValues:
   { id: 211,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 728,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 211 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
211
210
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 211;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Sending
211
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 211;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'james';
Pushing messages
[ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:Union Grill\nLocation:413 S Craig St, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: null,
       prev: 210,
       from: 'sarah',
       to: 'james',
       id: 211,
       time: 6000,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
[ { status: 'ok', id: '94288f8a-1e3d-4a78-8d72-fd907170ac1d' } ]
[ { id: '200d52df-3470-4f3d-adaf-1c602509b20a', status: 'ok' } ]
get try
Getting all tutoring
get try
deliveryCategories
Getting all delivery
Executing (221b70ae-8ffb-437b-b1a8-890ceb22c09d): BEGIN DEFERRED TRANSACTION;
Executing (2d5056d4-1f92-4190-a8a6-ccd2cba58a00): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (221b70ae-8ffb-437b-b1a8-890ceb22c09d): COMMIT;
Executing (2d5056d4-1f92-4190-a8a6-ccd2cba58a00): COMMIT;
Found successfully
Found successfully
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (275da841-fec6-498f-8b3f-84ef9fabd4ac): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (275da841-fec6-498f-8b3f-84ef9fabd4ac): COMMIT;
put try
Attempting to insert
Attempting insert...
{ requester_id: 'sarah',
  provider_id: '',
  service_type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  time: 0,
  location: { lat: 40.44509323161604, lng: -79.94512641257614 },
  provider_score: 0,
  requester_score: 0,
  dropOffLocation: { lat: 40.44509323161604, lng: -79.94512641257614 } }
Executing (0820f01d-100b-4b78-bc47-46ddea371d01): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Matches` (`id`,`requester_id`,`provider_id`,`service_type`,`subject_1`,`subject_2`,`subject_3`,`details`,`time`,`location`,`provider_score`,`requester_score`,`dropOffLocation`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12);
Executing (0820f01d-100b-4b78-bc47-46ddea371d01): COMMIT;
Inserted successfully
Getting matches API
IncomingMessage {
  _readableState:
   ReadableState {
     objectMode: false,
     highWaterMark: 16384,
     buffer: BufferList { length: 0 },
     length: 0,
     pipes: null,
     pipesCount: 0,
     flowing: null,
     ended: false,
     endEmitted: false,
     reading: false,
     sync: true,
     needReadable: false,
     emittedReadable: false,
     readableListening: false,
     resumeScheduled: false,
     emitClose: true,
     destroyed: false,
     defaultEncoding: 'utf8',
     awaitDrain: 0,
     readingMore: true,
     decoder: null,
     encoding: null },
  readable: true,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1911,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1424671,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1952,
        [Symbol(triggerId)]: 1913 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  connection:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1911,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1424671,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1952,
        [Symbol(triggerId)]: 1913 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: false,
  headers:
   { host: '128.2.204.187:5000',
     accept: '*/*',
     'accept-language': 'en-us',
     connection: 'keep-alive',
     'accept-encoding': 'gzip, deflate',
     'user-agent': 'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' },
  rawHeaders:
   [ 'Host',
     '128.2.204.187:5000',
     'Accept',
     '*/*',
     'Accept-Language',
     'en-us',
     'Connection',
     'keep-alive',
     'Accept-Encoding',
     'gzip, deflate',
     'User-Agent',
     'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url:
   '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
  method: 'GET',
  statusCode: null,
  statusMessage: null,
  client:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 1911,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1424671,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 1952,
        [Symbol(triggerId)]: 1913 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  _consuming: false,
  _dumped: false,
  next: [Function: next],
  baseUrl: '/api/match',
  originalUrl:
   '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
  _parsedUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     query:
      'limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     pathname: '/',
     path:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     href:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     _raw:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah' },
  params: {},
  query:
   { limit: '5',
     request:
      '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"","timetodeliver":0,"dropofflocation":{"lat":40.44509323161604,"lng":-79.94512641257614},"location":{"lat":40.44509323161604,"lng":-79.94512641257614}}',
     matchID: '729',
     requester_id: 'sarah' },
  res:
   ServerResponse {
     _events: { finish: [Function: bound resOnFinish] },
     _eventsCount: 1,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: false,
     chunkedEncoding: false,
     shouldKeepAlive: true,
     useChunkedEncodingByDefault: true,
     sendDate: true,
     _removedConnection: false,
     _removedContLen: false,
     _removedTE: false,
     _contentLength: null,
     _hasBody: true,
     _trailer: '',
     finished: false,
     _headerSent: false,
     socket:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 1911,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     connection:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 1911,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     _header: null,
     _onPendingData: [Function: bound updateOutgoingData],
     _sent100: false,
     _expect_continue: false,
     req: [Circular],
     locals: {},
     writeHead: [Function: writeHead],
     end: [Function: end],
     [Symbol(isCorked)]: false,
     [Symbol(outHeadersKey)]: { 'x-powered-by': [Array] } },
  _parsedOriginalUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     query:
      'limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     pathname: '/api/match/',
     path:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     href:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah',
     _raw:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D,%22location%22:%7B%22lat%22:40.44509323161604,%22lng%22:-79.94512641257614%7D%7D&matchID=729&requester_id=sarah' },
  sessionStore:
   SequelizeStore {
     options:
      { db: [Sequelize],
        checkExpirationInterval: 900000,
        expiration: 86400000,
        disableTouch: false },
     _events:
      { disconnect: [Function: ondisconnect],
        connect: [Function: onconnect] },
     _eventsCount: 2,
     _maxListeners: undefined,
     _expirationInterval:
      Timeout {
        _called: true,
        _idleTimeout: 900000,
        _idlePrev: null,
        _idleNext: null,
        _idleStart: 472,
        _onTimeout: [Function: bound clearExpiredSessions],
        _timerArgs: undefined,
        _repeat: 900000,
        _destroyed: false,
        _handle: [Timer],
        [Symbol(unrefed)]: false,
        [Symbol(asyncId)]: 8,
        [Symbol(triggerId)]: 1 },
     sessionModel: Session,
     generate: [Function] },
  sessionID: '1oa-1UTgEvFVrmB7XbWoodqLBDCutPtw',
  session:
   Session {
     cookie:
      { path: '/',
        _expires: null,
        originalMaxAge: null,
        httpOnly: false,
        secure: false } },
  body: {},
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [Array],
        _deserializers: [Array],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer] ],
     methods: { get: true },
     __acl: [Function],
     acl: [Function],
     __bind: [Function],
     bind: [Function],
     __checkout: [Function],
     checkout: [Function],
     __connect: [Function],
     connect: [Function],
     __copy: [Function],
     copy: [Function],
     __delete: [Function],
     delete: [Function],
     __get: [Function],
     get: [Function],
     __head: [Function],
     head: [Function],
     __link: [Function],
     link: [Function],
     __lock: [Function],
     lock: [Function],
     '__m-search': [Function],
     'm-search': [Function],
     __merge: [Function],
     merge: [Function],
     __mkactivity: [Function],
     mkactivity: [Function],
     __mkcalendar: [Function],
     mkcalendar: [Function],
     __mkcol: [Function],
     mkcol: [Function],
     __move: [Function],
     move: [Function],
     __notify: [Function],
     notify: [Function],
     __options: [Function],
     options: [Function],
     __patch: [Function],
     patch: [Function],
     __post: [Function],
     post: [Function],
     __propfind: [Function],
     propfind: [Function],
     __proppatch: [Function],
     proppatch: [Function],
     __purge: [Function],
     purge: [Function],
     __put: [Function],
     put: [Function],
     __rebind: [Function],
     rebind: [Function],
     __report: [Function],
     report: [Function],
     __search: [Function],
     search: [Function],
     __source: [Function],
     source: [Function],
     __subscribe: [Function],
     subscribe: [Function],
     __trace: [Function],
     trace: [Function],
     __unbind: [Function],
     unbind: [Function],
     __unlink: [Function],
     unlink: [Function],
     __unlock: [Function],
     unlock: [Function],
     __unsubscribe: [Function],
     unsubscribe: [Function],
     __all: [Function: all],
     all: [Function] } }
Attempting matching
{ limit: '5',
  request:
   '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"","timetodeliver":0,"dropofflocation":{"lat":40.44509323161604,"lng":-79.94512641257614},"location":{"lat":40.44509323161604,"lng":-79.94512641257614}}',
  matchID: '729',
  requester_id: 'sarah' }
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  timetodeliver: 0,
  dropofflocation: { lat: 40.44509323161604, lng: -79.94512641257614 },
  location: { lat: 40.44509323161604, lng: -79.94512641257614 } }
729
run
sarah
Executing (default): SELECT `User`.`id`, `Profile`.`id` AS `Profile.id`, `Profile`.`delivery` AS `Profile.delivery` FROM `Users` AS `User` INNER JOIN `Profiles` AS `Profile` ON `User`.`id` = `Profile`.`id` AND json_extract(`Profile`.`delivery`, '$.Food') IS NOT NULL;
User {
  dataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'james', delivery: [Object] },
     _previousDataValues: { id: 'james', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'james';
[ Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'james';
req
40.4476788 -79.9514778 40.44509323161604 -79.94512641257614
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'james';
getting profile
User {
  dataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'alice', delivery: [Object] },
     _previousDataValues: { id: 'alice', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'alice';
[ Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'alice';
req
40.4476602 -79.9514002 40.44509323161604 -79.94512641257614
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'alice';
getting profile
User {
  dataValues:
   { id: 'sarah',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'sarah',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'sarah', delivery: [Object] },
     _previousDataValues: { id: 'sarah', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'sarah';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'sarah';
req
40.445040501145 -79.9451721987268 40.44509323161604 -79.94512641257614
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
getting profile
[ Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
[ { id: 'james',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '15',
    time2: '10',
    time_request: 10.158744276034845,
    time2_request: 0 },
  { id: 'alice',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '10',
    time2: '10',
    time_request: 10.046005357700352,
    time2_request: 0 },
  { id: 'sarah',
    subject_1:
     { details: '', timetopickup: 0, timetodeliver: 0, preference: 1 },
    time: '10',
    time2: '10',
    time_request: 0.1171312698905432,
    time2_request: 0 } ]
running python script
delivery
{"0": "alice", "1": "sarah", "2": "james"}

data
{"0": "alice", "1": "sarah", "2": "james"}

{ '0': 'alice', '1': 'sarah', '2': 'james' }
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
delivery
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
212
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
213
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
214
Executing (default): INSERT INTO `NotificationLists` (`id`,`first`,`last`,`attempts`) VALUES (NULL,$1,$2,$3);
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 212;
Notification {
  dataValues:
   { id: 212,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _previousDataValues:
   { id: 212,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 212 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting next
212
213
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 212;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
212
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 212;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'alice';
Pushing messages
[ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 213,
       prev: null,
       from: 'sarah',
       to: 'alice',
       id: 212,
       time: 0,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 213;
Notification {
  dataValues:
   { id: 213,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _previousDataValues:
   { id: 213,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 213 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
213
212
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 213;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Setting next
213
214
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 213;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
213
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 213;
[ { status: 'ok', id: '8913316d-f16b-4a44-b599-3a83015fedb5' } ]
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Pushing messages
[ { to: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 214,
       prev: 212,
       from: 'sarah',
       to: 'sarah',
       id: 213,
       time: 6000,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 214;
Notification {
  dataValues:
   { id: 214,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _previousDataValues:
   { id: 214,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 729,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 214 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
214
213
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 214;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Sending
214
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 214;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'james';
Pushing messages
[ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: null,
       prev: 213,
       from: 'sarah',
       to: 'james',
       id: 214,
       time: 12000,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
[ { status: 'ok', id: '005defd8-b000-402d-8cbe-0c0b9c3e388a' } ]
[ { id: 'f60699a6-4383-4b8e-a1ac-8d23a99f714e', status: 'ok' } ]
get try
212
Executing (0416815e-6c34-4634-babf-3bcbc92fa7b3): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = '212';
Executing (0416815e-6c34-4634-babf-3bcbc92fa7b3): COMMIT;
Found status successfully
Fetched this notif...
Notification {
  dataValues:
   { id: 212,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: 213,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _previousDataValues:
   { id: 212,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: 213,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: '212' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
get try
Getting all tutoring
Executing (27f45784-1b55-42e5-ac91-4f99965fa4d7): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (27f45784-1b55-42e5-ac91-4f99965fa4d7): COMMIT;
Found successfully
get try
deliveryCategories
Getting all delivery
Executing (c73150ac-57a8-48aa-86e8-0cc99b0ba368): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (c73150ac-57a8-48aa-86e8-0cc99b0ba368): COMMIT;
Found successfully
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (e4a4eccc-e8ff-455b-b6fa-8727fba4b9d8): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (e4a4eccc-e8ff-455b-b6fa-8727fba4b9d8): COMMIT;
put try
{ id: 213, status: 'accepted' }
accepted
Attempting update
Executing (c78104e9-1e76-49b8-8dcf-d187b8222ab6): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 213;
Notification {
  dataValues:
   { id: 213,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: 212,
     next: 214,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _previousDataValues:
   { id: 213,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: 212,
     next: 214,
     attempts: 1,
     matchID: 729,
     listID: 99 },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 213 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Sending accepted notification
Executing (default): UPDATE `Notifications` SET `status`=$1 WHERE `id` = $2
Executing (05f34673-7a06-41ac-8e9d-a3fdfb5199e0): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `requester_id`, `provider_id`, `service_type`, `subject_1`, `subject_2`, `subject_3`, `details`, `time`, `location`, `timetodeliver`, `provider_score`, `requester_score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`id` = 729;
Match {
  dataValues:
   { id: 729,
     requester_id: 'sarah',
     provider_id: '',
     service_type: 'delivery',
     subject_1: 'Food',
     subject_2: '',
     subject_3: '',
     details: '',
     time: 0,
     location: { lat: 40.44509323161604, lng: -79.94512641257614 },
     timetodeliver: null,
     provider_score: 0,
     requester_score: 0,
     dropOffLocation: { lat: 40.44509323161604, lng: -79.94512641257614 } },
  _previousDataValues:
   { id: 729,
     requester_id: 'sarah',
     provider_id: '',
     service_type: 'delivery',
     subject_1: 'Food',
     subject_2: '',
     subject_3: '',
     details: '',
     time: 0,
     location: { lat: 40.44509323161604, lng: -79.94512641257614 },
     timetodeliver: null,
     provider_score: 0,
     requester_score: 0,
     dropOffLocation: { lat: 40.44509323161604, lng: -79.94512641257614 } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 729 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Matches', singular: 'Match' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'requester_id',
        'provider_id',
        'service_type',
        'subject_1',
        'subject_2',
        'subject_3',
        'details',
        'time',
        'location',
        'timetodeliver',
        'provider_score',
        'requester_score',
        'dropOffLocation' ] },
  isNewRecord: false }
sarah
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (default): UPDATE `Matches` SET `provider_id`=$1 WHERE `id` = $2
Token found
FirebaseToken {
  dataValues:
   { id: 'sarah',
     token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]' },
  _previousDataValues:
   { id: 'sarah',
     token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]' },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'sarah' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'FirebaseTokens', singular: 'FirebaseToken' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes: [ 'id', 'token' ] },
  isNewRecord: false }
Pushing messages
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
Executing (05f34673-7a06-41ac-8e9d-a3fdfb5199e0): COMMIT;
undefined
Executing (c78104e9-1e76-49b8-8dcf-d187b8222ab6): COMMIT;
undefined
put try
Attempting to insert
Attempting insert...
{ requester_id: 'sarah',
  provider_id: '',
  service_type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  time: 0,
  location: { lat: 40.44508146876745, lng: -79.94513867370408 },
  provider_score: 0,
  requester_score: 0,
  dropOffLocation: { lat: 40.44508146876745, lng: -79.94513867370408 } }
Executing (762f593d-ccd0-48b1-a02d-8149f7413230): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Matches` (`id`,`requester_id`,`provider_id`,`service_type`,`subject_1`,`subject_2`,`subject_3`,`details`,`time`,`location`,`provider_score`,`requester_score`,`dropOffLocation`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10,$11,$12);
Executing (762f593d-ccd0-48b1-a02d-8149f7413230): COMMIT;
Inserted successfully
Getting matches API
IncomingMessage {
  _readableState:
   ReadableState {
     objectMode: false,
     highWaterMark: 16384,
     buffer: BufferList { length: 0 },
     length: 0,
     pipes: null,
     pipesCount: 0,
     flowing: null,
     ended: false,
     endEmitted: false,
     reading: false,
     sync: true,
     needReadable: false,
     emittedReadable: false,
     readableListening: false,
     resumeScheduled: false,
     emitClose: true,
     destroyed: false,
     defaultEncoding: 'utf8',
     awaitDrain: 0,
     readingMore: true,
     decoder: null,
     encoding: null },
  readable: true,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3004,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1453307,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3046,
        [Symbol(triggerId)]: 3006 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  connection:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3004,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1453307,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3046,
        [Symbol(triggerId)]: 3006 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: false,
  headers:
   { host: '128.2.204.187:5000',
     accept: '*/*',
     'accept-language': 'en-us',
     connection: 'keep-alive',
     'accept-encoding': 'gzip, deflate',
     'user-agent': 'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' },
  rawHeaders:
   [ 'Host',
     '128.2.204.187:5000',
     'Accept',
     '*/*',
     'Accept-Language',
     'en-us',
     'Connection',
     'keep-alive',
     'Accept-Encoding',
     'gzip, deflate',
     'User-Agent',
     'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url:
   '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
  method: 'GET',
  statusCode: null,
  statusMessage: null,
  client:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3004,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1453307,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3046,
        [Symbol(triggerId)]: 3006 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  _consuming: false,
  _dumped: false,
  next: [Function: next],
  baseUrl: '/api/match',
  originalUrl:
   '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
  _parsedUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     query:
      'limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     pathname: '/',
     path:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     href:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     _raw:
      '/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah' },
  params: {},
  query:
   { limit: '5',
     request:
      '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"","timetodeliver":0,"dropofflocation":{"lat":40.44508146876745,"lng":-79.94513867370408},"location":{"lat":40.44508146876745,"lng":-79.94513867370408}}',
     matchID: '730',
     requester_id: 'sarah' },
  res:
   ServerResponse {
     _events: { finish: [Function: bound resOnFinish] },
     _eventsCount: 1,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: false,
     chunkedEncoding: false,
     shouldKeepAlive: true,
     useChunkedEncodingByDefault: true,
     sendDate: true,
     _removedConnection: false,
     _removedContLen: false,
     _removedTE: false,
     _contentLength: null,
     _hasBody: true,
     _trailer: '',
     finished: false,
     _headerSent: false,
     socket:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 3004,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     connection:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 3004,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     _header: null,
     _onPendingData: [Function: bound updateOutgoingData],
     _sent100: false,
     _expect_continue: false,
     req: [Circular],
     locals: {},
     writeHead: [Function: writeHead],
     end: [Function: end],
     [Symbol(isCorked)]: false,
     [Symbol(outHeadersKey)]: { 'x-powered-by': [Array] } },
  _parsedOriginalUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     query:
      'limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     pathname: '/api/match/',
     path:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     href:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah',
     _raw:
      '/api/match/?limit=5&request=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D,%22location%22:%7B%22lat%22:40.44508146876745,%22lng%22:-79.94513867370408%7D%7D&matchID=730&requester_id=sarah' },
  sessionStore:
   SequelizeStore {
     options:
      { db: [Sequelize],
        checkExpirationInterval: 900000,
        expiration: 86400000,
        disableTouch: false },
     _events:
      { disconnect: [Function: ondisconnect],
        connect: [Function: onconnect] },
     _eventsCount: 2,
     _maxListeners: undefined,
     _expirationInterval:
      Timeout {
        _called: true,
        _idleTimeout: 900000,
        _idlePrev: null,
        _idleNext: null,
        _idleStart: 472,
        _onTimeout: [Function: bound clearExpiredSessions],
        _timerArgs: undefined,
        _repeat: 900000,
        _destroyed: false,
        _handle: [Timer],
        [Symbol(unrefed)]: false,
        [Symbol(asyncId)]: 8,
        [Symbol(triggerId)]: 1 },
     sessionModel: Session,
     generate: [Function] },
  sessionID: '_sEUHn3wPsOSaahQ26YKf2Ldr0JQoBnA',
  session:
   Session {
     cookie:
      { path: '/',
        _expires: null,
        originalMaxAge: null,
        httpOnly: false,
        secure: false } },
  body: {},
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [Array],
        _deserializers: [Array],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer] ],
     methods: { get: true },
     __acl: [Function],
     acl: [Function],
     __bind: [Function],
     bind: [Function],
     __checkout: [Function],
     checkout: [Function],
     __connect: [Function],
     connect: [Function],
     __copy: [Function],
     copy: [Function],
     __delete: [Function],
     delete: [Function],
     __get: [Function],
     get: [Function],
     __head: [Function],
     head: [Function],
     __link: [Function],
     link: [Function],
     __lock: [Function],
     lock: [Function],
     '__m-search': [Function],
     'm-search': [Function],
     __merge: [Function],
     merge: [Function],
     __mkactivity: [Function],
     mkactivity: [Function],
     __mkcalendar: [Function],
     mkcalendar: [Function],
     __mkcol: [Function],
     mkcol: [Function],
     __move: [Function],
     move: [Function],
     __notify: [Function],
     notify: [Function],
     __options: [Function],
     options: [Function],
     __patch: [Function],
     patch: [Function],
     __post: [Function],
     post: [Function],
     __propfind: [Function],
     propfind: [Function],
     __proppatch: [Function],
     proppatch: [Function],
     __purge: [Function],
     purge: [Function],
     __put: [Function],
     put: [Function],
     __rebind: [Function],
     rebind: [Function],
     __report: [Function],
     report: [Function],
     __search: [Function],
     search: [Function],
     __source: [Function],
     source: [Function],
     __subscribe: [Function],
     subscribe: [Function],
     __trace: [Function],
     trace: [Function],
     __unbind: [Function],
     unbind: [Function],
     __unlink: [Function],
     unlink: [Function],
     __unlock: [Function],
     unlock: [Function],
     __unsubscribe: [Function],
     unsubscribe: [Function],
     __all: [Function: all],
     all: [Function] } }
Attempting matching
{ limit: '5',
  request:
   '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"","timetodeliver":0,"dropofflocation":{"lat":40.44508146876745,"lng":-79.94513867370408},"location":{"lat":40.44508146876745,"lng":-79.94513867370408}}',
  matchID: '730',
  requester_id: 'sarah' }
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  timetodeliver: 0,
  dropofflocation: { lat: 40.44508146876745, lng: -79.94513867370408 },
  location: { lat: 40.44508146876745, lng: -79.94513867370408 } }
730
run
sarah
Executing (default): SELECT `User`.`id`, `Profile`.`id` AS `Profile.id`, `Profile`.`delivery` AS `Profile.delivery` FROM `Users` AS `User` INNER JOIN `Profiles` AS `Profile` ON `User`.`id` = `Profile`.`id` AND json_extract(`Profile`.`delivery`, '$.Food') IS NOT NULL;
User {
  dataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'james', delivery: [Object] },
     _previousDataValues: { id: 'james', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'james';
[ Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'james';
req
40.4476788 -79.9514778 40.44508146876745 -79.94513867370408
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'james';
getting profile
User {
  dataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'alice', delivery: [Object] },
     _previousDataValues: { id: 'alice', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'alice';
[ Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'alice';
req
40.4476602 -79.9514002 40.44508146876745 -79.94513867370408
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'alice';
getting profile
User {
  dataValues:
   { id: 'sarah',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'sarah',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'sarah', delivery: [Object] },
     _previousDataValues: { id: 'sarah', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `provider_id` AS `id`, `details`, `time`, `location`, `provider_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'sarah';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'sarah';
req
40.445040501145 -79.9451721987268 40.44508146876745 -79.94513867370408
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
getting profile
[ Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'james',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'alice',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 5,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
[ { id: 'james',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '15',
    time2: '10',
    time_request: 10.153816377554934,
    time2_request: 0 },
  { id: 'alice',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '10',
    time2: '10',
    time_request: 10.041135751595773,
    time2_request: 0 },
  { id: 'sarah',
    subject_1:
     { details: '', timetopickup: 0, timetodeliver: 0, preference: 1 },
    time: '10',
    time2: '10',
    time_request: 0.08944271659031085,
    time2_request: 0 } ]
running python script
delivery
{"0": "sarah", "1": "james", "2": "alice"}

data
{"0": "sarah", "1": "james", "2": "alice"}

{ '0': 'sarah', '1': 'james', '2': 'alice' }
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
delivery
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
215
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
216
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
217
Executing (default): INSERT INTO `NotificationLists` (`id`,`first`,`last`,`attempts`) VALUES (NULL,$1,$2,$3);
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 215;
Notification {
  dataValues:
   { id: 215,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: 100 },
  _previousDataValues:
   { id: 215,
     to: 'sarah',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 215 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting next
215
216
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 215;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
215
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 215;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Pushing messages
[ { to: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 216,
       prev: null,
       from: 'sarah',
       to: 'sarah',
       id: 215,
       time: 0,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 216;
Notification {
  dataValues:
   { id: 216,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: 100 },
  _previousDataValues:
   { id: 216,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 216 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
216
215
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 216;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Setting next
216
217
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 216;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
216
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 216;
[ { status: 'ok', id: '9a91bc17-5180-4fda-b3f7-a069facca8df' } ]
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'james';
Pushing messages
[ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 217,
       prev: 215,
       from: 'sarah',
       to: 'james',
       id: 216,
       time: 6000,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 217;
Notification {
  dataValues:
   { id: 217,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: 100 },
  _previousDataValues:
   { id: 217,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Request',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 730,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 217 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
217
216
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 217;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Sending
217
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 217;
[ { id: 'f0d5dcb5-abc7-4d54-9718-aa056262343a', status: 'ok' } ]
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'alice';
Pushing messages
[ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
    sound: 'default',
    title: 'Match Request',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is requesting delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: null,
       prev: 216,
       from: 'sarah',
       to: 'alice',
       id: 217,
       time: 12000,
       title: 'Match Request' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
      sound: 'default',
      title: 'Match Request',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
[ { status: 'ok', id: 'b574495c-e741-443d-a87a-6e060f1a95b0' } ]
get try
Getting all tutoring
get try
deliveryCategories
Getting all delivery
Executing (a481e249-c866-4b72-a906-9755603b4aa7): BEGIN DEFERRED TRANSACTION;
Executing (614cd3e9-24ed-47fd-922f-76cdfa52a77a): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (a481e249-c866-4b72-a906-9755603b4aa7): COMMIT;
Executing (614cd3e9-24ed-47fd-922f-76cdfa52a77a): COMMIT;
Found successfully
Found successfully
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (7703c06d-b680-4138-b32f-33899144bd1c): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (7703c06d-b680-4138-b32f-33899144bd1c): COMMIT;
get try
deliveryCategories
Getting all delivery
get try
Getting all tutoring
Executing (3a5eeae6-af84-44fa-991f-602b7b944051): BEGIN DEFERRED TRANSACTION;
Executing (abd2be81-b5c8-4ac2-ab14-08196527b4a4): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (abd2be81-b5c8-4ac2-ab14-08196527b4a4): COMMIT;
Executing (3a5eeae6-af84-44fa-991f-602b7b944051): COMMIT;
Found successfully
Found successfully
put try
Attempting to insert
Attempting insert...
{ requester_id: '',
  provider_id: 'sarah',
  service_type: 'delivery',
  details: '',
  time: 0,
  location: { lat: 40.445057342672, lng: -79.945153181001 },
  score: 0,
  dropOffLocation: { lat: 40.445057342672, lng: -79.945153181001 } }
Executing (17a90b20-7cf0-45e8-872a-4295d8bb6e89): BEGIN DEFERRED TRANSACTION;
Executing (default): INSERT INTO `Matches` (`id`,`requester_id`,`provider_id`,`service_type`,`details`,`time`,`location`,`dropOffLocation`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7);
Executing (17a90b20-7cf0-45e8-872a-4295d8bb6e89): COMMIT;
Inserted successfully
Getting matches API
IncomingMessage {
  _readableState:
   ReadableState {
     objectMode: false,
     highWaterMark: 16384,
     buffer: BufferList { length: 0 },
     length: 0,
     pipes: null,
     pipesCount: 0,
     flowing: null,
     ended: false,
     endEmitted: false,
     reading: false,
     sync: true,
     needReadable: false,
     emittedReadable: false,
     readableListening: false,
     resumeScheduled: false,
     emitClose: true,
     destroyed: false,
     defaultEncoding: 'utf8',
     awaitDrain: 0,
     readingMore: true,
     decoder: null,
     encoding: null },
  readable: true,
  _events: {},
  _eventsCount: 0,
  _maxListeners: undefined,
  socket:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3891,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1500010,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3933,
        [Symbol(triggerId)]: 3893 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  connection:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3891,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1500010,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3933,
        [Symbol(triggerId)]: 3893 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  httpVersionMajor: 1,
  httpVersionMinor: 1,
  httpVersion: '1.1',
  complete: false,
  headers:
   { host: '128.2.204.187:5000',
     accept: '*/*',
     'accept-language': 'en-us',
     connection: 'keep-alive',
     'accept-encoding': 'gzip, deflate',
     'user-agent': 'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' },
  rawHeaders:
   [ 'Host',
     '128.2.204.187:5000',
     'Accept',
     '*/*',
     'Accept-Language',
     'en-us',
     'Connection',
     'keep-alive',
     'Accept-Encoding',
     'gzip, deflate',
     'User-Agent',
     'Expo/2.10.0.105122 CFNetwork/978.0.7 Darwin/18.5.0' ],
  trailers: {},
  rawTrailers: [],
  aborted: false,
  upgrade: false,
  url:
   '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
  method: 'GET',
  statusCode: null,
  statusMessage: null,
  client:
   Socket {
     connecting: false,
     _hadError: false,
     _handle:
      TCP {
        reading: true,
        owner: [Circular],
        onread: [Function: onread],
        onconnection: null,
        _consumed: true },
     _parent: null,
     _host: null,
     _readableState:
      ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { length: 0 },
        length: 0,
        pipes: null,
        pipesCount: 0,
        flowing: true,
        ended: false,
        endEmitted: false,
        reading: true,
        sync: false,
        needReadable: true,
        emittedReadable: false,
        readableListening: false,
        resumeScheduled: false,
        emitClose: false,
        destroyed: false,
        defaultEncoding: 'utf8',
        awaitDrain: 0,
        readingMore: false,
        decoder: null,
        encoding: null },
     readable: true,
     _events:
      { end: [Array],
        drain: [Array],
        timeout: [Function: socketOnTimeout],
        data: [Function: bound socketOnData],
        error: [Function: socketOnError],
        close: [Array],
        resume: [Function: onSocketResume],
        pause: [Function: onSocketPause] },
     _eventsCount: 8,
     _maxListeners: undefined,
     _writableState:
      WritableState {
        objectMode: false,
        highWaterMark: 16384,
        finalCalled: false,
        needDrain: false,
        ending: false,
        ended: false,
        finished: false,
        destroyed: false,
        decodeStrings: false,
        defaultEncoding: 'utf8',
        length: 0,
        writing: false,
        corked: 0,
        sync: false,
        bufferProcessing: false,
        onwrite: [Function: bound onwrite],
        writecb: null,
        writelen: 0,
        bufferedRequest: null,
        lastBufferedRequest: null,
        pendingcb: 0,
        prefinished: false,
        errorEmitted: false,
        emitClose: false,
        bufferedRequestCount: 0,
        corkedRequestsFree: [Object] },
     writable: true,
     allowHalfOpen: true,
     _sockname: null,
     _pendingData: null,
     _pendingEncoding: '',
     server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     _server:
      Server {
        _events: [Object],
        _eventsCount: 2,
        _maxListeners: undefined,
        _connections: 1,
        _handle: [TCP],
        _usingWorkers: false,
        _workers: [],
        _unref: false,
        allowHalfOpen: true,
        pauseOnConnect: false,
        httpAllowHalfOpen: false,
        timeout: 120000,
        keepAliveTimeout: 5000,
        _pendingResponseData: 0,
        maxHeadersCount: null,
        _connectionKey: '6::::5000',
        [Symbol(IncomingMessage)]: [Function],
        [Symbol(ServerResponse)]: [Function],
        [Symbol(asyncId)]: 223 },
     parser:
      HTTPParser {
        '0': [Function: parserOnHeaders],
        '1': [Function: parserOnHeadersComplete],
        '2': [Function: parserOnBody],
        '3': [Function: parserOnMessageComplete],
        '4': [Function: bound onParserExecute],
        _headers: [],
        _url: '',
        _consumed: true,
        socket: [Circular],
        incoming: [Circular],
        outgoing: null,
        maxHeaderPairs: 2000,
        onIncoming: [Function: bound parserOnIncoming] },
     on: [Function: socketOnWrap],
     _paused: false,
     _httpMessage:
      ServerResponse {
        _events: [Object],
        _eventsCount: 1,
        _maxListeners: undefined,
        output: [],
        outputEncodings: [],
        outputCallbacks: [],
        outputSize: 0,
        writable: true,
        _last: false,
        chunkedEncoding: false,
        shouldKeepAlive: true,
        useChunkedEncodingByDefault: true,
        sendDate: true,
        _removedConnection: false,
        _removedContLen: false,
        _removedTE: false,
        _contentLength: null,
        _hasBody: true,
        _trailer: '',
        finished: false,
        _headerSent: false,
        socket: [Circular],
        connection: [Circular],
        _header: null,
        _onPendingData: [Function: bound updateOutgoingData],
        _sent100: false,
        _expect_continue: false,
        req: [Circular],
        locals: {},
        writeHead: [Function: writeHead],
        end: [Function: end],
        [Symbol(isCorked)]: false,
        [Symbol(outHeadersKey)]: [Object] },
     [Symbol(asyncId)]: 3891,
     [Symbol(lastWriteQueueSize)]: 0,
     [Symbol(timeout)]:
      Timeout {
        _called: false,
        _idleTimeout: 120000,
        _idlePrev: [TimersList],
        _idleNext: [TimersList],
        _idleStart: 1500010,
        _onTimeout: [Function: bound ],
        _timerArgs: undefined,
        _repeat: null,
        _destroyed: false,
        [Symbol(unrefed)]: true,
        [Symbol(asyncId)]: 3933,
        [Symbol(triggerId)]: 3893 },
     [Symbol(kBytesRead)]: 0,
     [Symbol(kBytesWritten)]: 0 },
  _consuming: false,
  _dumped: false,
  next: [Function: next],
  baseUrl: '/api/match',
  originalUrl:
   '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
  _parsedUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     pathname: '/',
     path:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     href:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     _raw:
      '/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah' },
  params: {},
  query:
   { limit: '5',
     offer:
      '{"type":"delivery","subject_1":"Food","subject_2":"","subject_3":"","details":"","timetodeliver":0,"dropofflocation":{"lat":40.445057342672,"lng":-79.945153181001},"location":{"lat":40.445057342672,"lng":-79.945153181001}}',
     matchID: '731',
     provider_id: 'sarah' },
  res:
   ServerResponse {
     _events: { finish: [Function: bound resOnFinish] },
     _eventsCount: 1,
     _maxListeners: undefined,
     output: [],
     outputEncodings: [],
     outputCallbacks: [],
     outputSize: 0,
     writable: true,
     _last: false,
     chunkedEncoding: false,
     shouldKeepAlive: true,
     useChunkedEncodingByDefault: true,
     sendDate: true,
     _removedConnection: false,
     _removedContLen: false,
     _removedTE: false,
     _contentLength: null,
     _hasBody: true,
     _trailer: '',
     finished: false,
     _headerSent: false,
     socket:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 3891,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     connection:
      Socket {
        connecting: false,
        _hadError: false,
        _handle: [TCP],
        _parent: null,
        _host: null,
        _readableState: [ReadableState],
        readable: true,
        _events: [Object],
        _eventsCount: 8,
        _maxListeners: undefined,
        _writableState: [WritableState],
        writable: true,
        allowHalfOpen: true,
        _sockname: null,
        _pendingData: null,
        _pendingEncoding: '',
        server: [Server],
        _server: [Server],
        parser: [HTTPParser],
        on: [Function: socketOnWrap],
        _paused: false,
        _httpMessage: [Circular],
        [Symbol(asyncId)]: 3891,
        [Symbol(lastWriteQueueSize)]: 0,
        [Symbol(timeout)]: [Timeout],
        [Symbol(kBytesRead)]: 0,
        [Symbol(kBytesWritten)]: 0 },
     _header: null,
     _onPendingData: [Function: bound updateOutgoingData],
     _sent100: false,
     _expect_continue: false,
     req: [Circular],
     locals: {},
     writeHead: [Function: writeHead],
     end: [Function: end],
     [Symbol(isCorked)]: false,
     [Symbol(outHeadersKey)]: { 'x-powered-by': [Array] } },
  _parsedOriginalUrl:
   Url {
     protocol: null,
     slashes: null,
     auth: null,
     host: null,
     port: null,
     hostname: null,
     hash: null,
     search:
      '?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     query:
      'limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     pathname: '/api/match/',
     path:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     href:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah',
     _raw:
      '/api/match/?limit=5&offer=%7B%22type%22:%22delivery%22,%22subject_1%22:%22Food%22,%22subject_2%22:%22%22,%22subject_3%22:%22%22,%22details%22:%22%22,%22timetodeliver%22:0,%22dropofflocation%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D,%22location%22:%7B%22lat%22:40.445057342672,%22lng%22:-79.945153181001%7D%7D&matchID=731&provider_id=sarah' },
  sessionStore:
   SequelizeStore {
     options:
      { db: [Sequelize],
        checkExpirationInterval: 900000,
        expiration: 86400000,
        disableTouch: false },
     _events:
      { disconnect: [Function: ondisconnect],
        connect: [Function: onconnect] },
     _eventsCount: 2,
     _maxListeners: undefined,
     _expirationInterval:
      Timeout {
        _called: true,
        _idleTimeout: 900000,
        _idlePrev: null,
        _idleNext: null,
        _idleStart: 472,
        _onTimeout: [Function: bound clearExpiredSessions],
        _timerArgs: undefined,
        _repeat: 900000,
        _destroyed: false,
        _handle: [Timer],
        [Symbol(unrefed)]: false,
        [Symbol(asyncId)]: 8,
        [Symbol(triggerId)]: 1 },
     sessionModel: Session,
     generate: [Function] },
  sessionID: 'sMt3iG-us4vR8PMGqXBHCjkhPj9CMIcz',
  session:
   Session {
     cookie:
      { path: '/',
        _expires: null,
        originalMaxAge: null,
        httpOnly: false,
        secure: false } },
  body: {},
  _passport:
   { instance:
      Authenticator {
        _key: 'passport',
        _strategies: [Object],
        _serializers: [Array],
        _deserializers: [Array],
        _infoTransformers: [],
        _framework: [Object],
        _userProperty: 'user',
        _sm: [SessionManager] } },
  route:
   Route {
     path: '/',
     stack: [ [Layer] ],
     methods: { get: true },
     __acl: [Function],
     acl: [Function],
     __bind: [Function],
     bind: [Function],
     __checkout: [Function],
     checkout: [Function],
     __connect: [Function],
     connect: [Function],
     __copy: [Function],
     copy: [Function],
     __delete: [Function],
     delete: [Function],
     __get: [Function],
     get: [Function],
     __head: [Function],
     head: [Function],
     __link: [Function],
     link: [Function],
     __lock: [Function],
     lock: [Function],
     '__m-search': [Function],
     'm-search': [Function],
     __merge: [Function],
     merge: [Function],
     __mkactivity: [Function],
     mkactivity: [Function],
     __mkcalendar: [Function],
     mkcalendar: [Function],
     __mkcol: [Function],
     mkcol: [Function],
     __move: [Function],
     move: [Function],
     __notify: [Function],
     notify: [Function],
     __options: [Function],
     options: [Function],
     __patch: [Function],
     patch: [Function],
     __post: [Function],
     post: [Function],
     __propfind: [Function],
     propfind: [Function],
     __proppatch: [Function],
     proppatch: [Function],
     __purge: [Function],
     purge: [Function],
     __put: [Function],
     put: [Function],
     __rebind: [Function],
     rebind: [Function],
     __report: [Function],
     report: [Function],
     __search: [Function],
     search: [Function],
     __source: [Function],
     source: [Function],
     __subscribe: [Function],
     subscribe: [Function],
     __trace: [Function],
     trace: [Function],
     __unbind: [Function],
     unbind: [Function],
     __unlink: [Function],
     unlink: [Function],
     __unlock: [Function],
     unlock: [Function],
     __unsubscribe: [Function],
     unsubscribe: [Function],
     __all: [Function: all],
     all: [Function] } }
Attempting matching
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  timetodeliver: 0,
  dropofflocation: { lat: 40.445057342672, lng: -79.945153181001 },
  location: { lat: 40.445057342672, lng: -79.945153181001 } }
731
run
sarah
Executing (default): SELECT `User`.`id`, `Profile`.`id` AS `Profile.id`, `Profile`.`delivery` AS `Profile.delivery` FROM `Users` AS `User` INNER JOIN `Profiles` AS `Profile` ON `User`.`id` = `Profile`.`id` AND json_extract(`Profile`.`deliveryNeeds`, '$.Food') IS NOT NULL;
User {
  dataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'james',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'james', delivery: [Object] },
     _previousDataValues: { id: 'james', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'james';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'james';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  timetodeliver: 0,
  dropofflocation: { lat: 40.445057342672, lng: -79.945153181001 },
  location: { lat: 40.445057342672, lng: -79.945153181001 } }
40.4476788 -79.9514778 40.445057342672 -79.945153181001
{ time: 10.157117053515229 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'james';
getting profile
Profile {
  dataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _previousDataValues:
   { id: 'james',
     nameFirst: 'James',
     nameLast: 'Smith',
     phone: '123-456-7890',
     bio: null,
     tutoring: { English: [Object], Math: [Object], timetotutor: '15' },
     delivery: { Food: [Object], timetopickup: '15', timetodeliver: '10' },
     tutoringNeeds: { History: [Object], timetogettutored: '20' },
     deliveryNeeds: { Food: [Object], timetopickup: '10' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'james' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
User {
  dataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _previousDataValues:
   { id: 'alice',
     Profile:
      Profile {
        dataValues: [Object],
        _previousDataValues: [Object],
        _changed: {},
        _modelOptions: [Object],
        _options: [Object],
        isNewRecord: false } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: null,
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Users', singular: 'User' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     include: [ [Object] ],
     includeNames: [ 'Profile' ],
     includeMap: { Profile: [Object] },
     includeValidated: true,
     attributes: [ 'id' ],
     raw: true },
  isNewRecord: false,
  Profile:
   Profile {
     dataValues: { id: 'alice', delivery: [Object] },
     _previousDataValues: { id: 'alice', delivery: [Object] },
     _changed: {},
     _modelOptions:
      { timestamps: false,
        validate: {},
        freezeTableName: false,
        underscored: false,
        paranoid: false,
        rejectOnEmpty: false,
        whereCollection: [Object],
        schema: null,
        schemaDelimiter: '',
        defaultScope: {},
        scopes: {},
        indexes: [],
        name: [Object],
        omitNull: false,
        sequelize: [Sequelize],
        hooks: {} },
     _options:
      { isNewRecord: false,
        _schema: null,
        _schemaDelimiter: '',
        include: undefined,
        includeNames: undefined,
        includeMap: undefined,
        includeValidated: true,
        raw: true,
        attributes: [Array] },
     isNewRecord: false } }
Executing (default): SELECT `requester_id` AS `id`, `details`, `time`, `location`, `requester_score` AS `score`, `dropOffLocation` FROM `Matches` AS `Match` WHERE `Match`.`service_type` = 'delivery' AND `Match`.`subject_1` = 'Food' AND `Match`.`subject_2` = '' AND `Match`.`subject_3` = '' AND `Match`.`provider_id` = 'alice';
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
Executing (default): SELECT `id`, `latitude`, `longitude`, `userID`, `createdAt`, `updatedAt` FROM `Geolocations` AS `Geolocation` WHERE `Geolocation`.`userID` = 'alice';
req
{ type: 'delivery',
  subject_1: 'Food',
  subject_2: '',
  subject_3: '',
  details: '',
  timetodeliver: 0,
  dropofflocation: { lat: 40.445057342672, lng: -79.945153181001 },
  location: { lat: 40.445057342672, lng: -79.945153181001 } }
40.4476602 -79.9514002 40.445057342672 -79.945153181001
{ time: 10.044542907060674 }
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'alice';
getting profile
Profile {
  dataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _previousDataValues:
   { id: 'alice',
     nameFirst: 'Alice',
     nameLast: 'Jones',
     phone: '345-678-9012',
     bio: null,
     tutoring: { timetotutor: '10', English: [Object] },
     delivery: { Food: [Object], timetopickup: '10', timetodeliver: '10' },
     tutoringNeeds:
      { Math: [Object], History: [Object], timetogettutored: '10' },
     deliveryNeeds: { Food: [Object], timetopickup: '5' } },
  _changed: {},
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 'alice' },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Profiles', singular: 'Profile' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'nameFirst',
        'nameLast',
        'phone',
        'bio',
        'tutoring',
        'delivery',
        'tutoringNeeds',
        'deliveryNeeds' ] },
  isNewRecord: false }
[ Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.56844127925357,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 1.6394708009076633,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 3.2656631150312796,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 5.163709947421473,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0.03936838138292884,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false },
  Match {
    dataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _previousDataValues:
     { id: 'sarah',
       details: '',
       time: 0,
       location: [Object],
       score: 0,
       dropOffLocation: [Object] },
    _changed: {},
    _modelOptions:
     { timestamps: false,
       validate: {},
       freezeTableName: false,
       underscored: false,
       paranoid: false,
       rejectOnEmpty: false,
       whereCollection: [Object],
       schema: null,
       schemaDelimiter: '',
       defaultScope: {},
       scopes: {},
       indexes: [],
       name: [Object],
       omitNull: false,
       sequelize: [Sequelize],
       hooks: {} },
    _options:
     { isNewRecord: false,
       _schema: null,
       _schemaDelimiter: '',
       raw: true,
       attributes: [Array] },
    isNewRecord: false } ]
[ { id: 'james',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '10',
    time2: 1,
    time_request: 10.157117053515229,
    time2_request: 1 },
  { id: 'alice',
    subject_1:
     { details: '',
       timetopickup: 0,
       timetodeliver: 0,
       preference: '3' },
    time: '5',
    time2: 1,
    time_request: 10.044542907060674,
    time2_request: 1 } ]
running python script
delivery
{"0": "james", "1": "alice"}

data
{"0": "james", "1": "alice"}

{ '0': 'james', '1': 'alice' }
[ 'james', 'alice' ]
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
delivery
4765 Forbes Ave, Pittsburgh, PA 15213, USA
4765 Forbes Ave, Pittsburgh, PA 15213, USA
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
218
Executing (default): INSERT INTO `Notifications` (`id`,`to`,`from`,`message`,`title`,`status`,`prev`,`next`,`attempts`,`matchID`,`listID`) VALUES (NULL,$1,$2,$3,$4,$5,$6,$7,$8,$9,$10);
219
Executing (default): INSERT INTO `NotificationLists` (`id`,`first`,`last`,`attempts`) VALUES (NULL,$1,$2,$3);
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 218;
Notification {
  dataValues:
   { id: 218,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 731,
     listID: 101 },
  _previousDataValues:
   { id: 218,
     to: 'james',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 731,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 218 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting next
218
219
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 218;
Executing (default): UPDATE `Notifications` SET `next`=$1 WHERE `id` = $2
Sending
218
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 218;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'james';
Pushing messages
[ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: 219,
       prev: null,
       from: 'sarah',
       to: 'james',
       id: 218,
       time: 0,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[2VbZ08L7D_3u2C3jOaw6Mv]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
Set list ID
Setting id
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 219;
Notification {
  dataValues:
   { id: 219,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 731,
     listID: 101 },
  _previousDataValues:
   { id: 219,
     to: 'alice',
     from: 'sarah',
     message:
      'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
     title: 'Match Offer',
     status: null,
     prev: null,
     next: null,
     attempts: 1,
     matchID: 731,
     listID: null },
  _changed: { listID: true },
  _modelOptions:
   { timestamps: false,
     validate: {},
     freezeTableName: false,
     underscored: false,
     paranoid: false,
     rejectOnEmpty: false,
     whereCollection: { id: 219 },
     schema: null,
     schemaDelimiter: '',
     defaultScope: {},
     scopes: {},
     indexes: [],
     name: { plural: 'Notifications', singular: 'Notification' },
     omitNull: false,
     sequelize:
      Sequelize {
        options: [Object],
        config: [Object],
        dialect: [SqliteDialect],
        queryInterface: [QueryInterface],
        models: [Object],
        modelManager: [ModelManager],
        connectionManager: [ConnectionManager],
        importCache: [Object] },
     hooks: {} },
  _options:
   { isNewRecord: false,
     _schema: null,
     _schemaDelimiter: '',
     raw: true,
     attributes:
      [ 'id',
        'to',
        'from',
        'message',
        'title',
        'status',
        'prev',
        'next',
        'attempts',
        'matchID',
        'listID' ] },
  isNewRecord: false }
Executing (default): UPDATE `Notifications` SET `listID`=$1 WHERE `id` = $2
Setting prev
219
218
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 219;
Executing (default): UPDATE `Notifications` SET `prev`=$1 WHERE `id` = $2
Sending
219
Executing (default): SELECT `id`, `to`, `from`, `message`, `title`, `status`, `prev`, `next`, `attempts`, `matchID`, `listID` FROM `Notifications` AS `Notification` WHERE `Notification`.`id` = 219;
[ { id: 'd95ac0fb-62c7-4f3f-b73e-4c6f49bd3615', status: 'ok' } ]
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'alice';
Pushing messages
[ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
    sound: 'default',
    title: 'Match Offer',
    data:
     { isRequest: false,
       attempt: undefined,
       message:
        'sarah is offering delivery: Food, , \nDetails:\nLocation:4765 Forbes Ave, Pittsburgh, PA 15213, USA\nDrop-off Location:4765 Forbes Ave, Pittsburgh, PA 15213, USA',
       next: null,
       prev: 218,
       from: 'sarah',
       to: 'alice',
       id: 219,
       time: 6000,
       title: 'Match Offer' },
    priority: 'high',
    channelId: 'channel1' } ]
chunks
[ [ { to: 'ExponentPushToken[toof6rIPQDNDYJ54pmM6hz]',
      sound: 'default',
      title: 'Match Offer',
      data: [Object],
      priority: 'high',
      channelId: 'channel1' } ] ]
[]
[ { status: 'ok', id: 'a29181b7-bd3f-4239-81ac-4f8a0ac96648' } ]
Executing (default): DELETE FROM `Sessions` WHERE `expires` < '2019-05-13 20:51:33.257 +00:00'
get try
deliveryCategories
Getting all delivery
get try
Getting all tutoring
Executing (8fcbd0e9-db22-4aa2-b465-865c315846c4): BEGIN DEFERRED TRANSACTION;
Executing (d155e2fb-3715-4e47-946c-f4c71726f383): BEGIN DEFERRED TRANSACTION;
Getting
sarah
sarah
Executing (default): SELECT `id`, `pwHash` FROM `Users` AS `User` WHERE `User`.`id` = 'sarah';
Executing (default): SELECT `category` FROM `DeliveryCategories` AS `DeliveryCategory`;
Executing (default): SELECT `subject` FROM `TutoringSubjects` AS `TutoringSubject`;
Executing (default): SELECT `id`, `nameFirst`, `nameLast`, `phone`, `bio`, `tutoring`, `delivery`, `tutoringNeeds`, `deliveryNeeds` FROM `Profiles` AS `Profile` WHERE `Profile`.`id` = 'sarah';
Executing (8fcbd0e9-db22-4aa2-b465-865c315846c4): COMMIT;
Executing (d155e2fb-3715-4e47-946c-f4c71726f383): COMMIT;
Found successfully
Found successfully
put try token
{ token: 'ExponentPushToken[2VQdGuPHizlWk95Moa6jYx]',
  id: 'sarah' }
Attempting to insert
sarah
Attempting insert...
Inserted successfully
Executing (cb947dc7-35e8-47be-b6c3-248e78e29824): BEGIN DEFERRED TRANSACTION;
Executing (default): SELECT `id`, `token` FROM `FirebaseTokens` AS `FirebaseToken` WHERE `FirebaseToken`.`id` = 'sarah';
Executing (cb947dc7-35e8-47be-b6c3-248e78e29824): COMMIT;
